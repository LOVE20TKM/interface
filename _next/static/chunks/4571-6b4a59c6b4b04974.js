"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[4571],{18456:(t,e,a)=>{a.d(e,{k:()=>c});var n=a(66320),r=a(49154),s=a(16006),i=a(58547),o=a(73550);async function c(t,e){async function a(e){if(e.endsWith(o.vB.slice(2))){let a=(0,r.B)((0,n.iN)(e,-64,-32)),i=(0,n.iN)(e,0,-64).slice(2).match(/.{1,64}/g),c=await Promise.all(i.map(e=>o.BH.slice(2)!==e?t.request({method:"eth_getTransactionReceipt",params:[`0x${e}`]},{dedupe:!0}):void 0)),u=c.some(t=>null===t)?100:c.every(t=>t?.status==="0x1")?200:c.every(t=>t?.status==="0x0")?500:600;return{atomic:!1,chainId:(0,s.ME)(a),receipts:c.filter(Boolean),status:u,version:"2.0.0"}}return t.request({method:"wallet_getCallsStatus",params:[e]})}let{atomic:c=!1,chainId:u,receipts:d,version:l="2.0.0",...h}=await a(e.id),[m,p]=(()=>{let t=h.status;return t>=100&&t<200?["pending",t]:t>=200&&t<300?["success",t]:t>=300&&t<700?["failure",t]:"CONFIRMED"===t?["success",200]:"PENDING"===t?["pending",100]:[void 0,t]})();return{...h,atomic:c,chainId:u?(0,s.ME)(u):void 0,receipts:d?.map(t=>({...t,blockNumber:(0,s.uU)(t.blockNumber),gasUsed:(0,s.uU)(t.gasUsed),status:i.Lj[t.status]}))??[],statusCode:p,status:m,version:l}}},21842:(t,e,a)=>{a.d(e,{w:()=>n});async function n(t,e){return await t.request({method:"wallet_watchAsset",params:e},{retryCount:0})}},23272:(t,e,a)=>{a.d(e,{c:()=>u});var n=a(76200),r=a(71503),s=a(92108),i=a(3190),o=a(40474),c=a(18456);async function u(t,e){let a,{id:n,pollingInterval:u=t.pollingInterval,status:l=({statusCode:t})=>t>=200,timeout:h=6e4}=e,m=(0,o.A)(["waitForCallsStatus",t.uid,n]),{promise:p,resolve:w,reject:f}=(0,i.Y)(),v=(0,r.lB)(m,{resolve:w,reject:f},e=>{let r=(0,s.w)(async()=>{let s=t=>{clearTimeout(a),r(),t(),v()};try{let a=await (0,c.k)(t,{id:n});if(!l(a))return;s(()=>e.resolve(a))}catch(t){s(()=>e.reject(t))}},{interval:u,emitOnBegin:!0});return r});return a=h?setTimeout(()=>{v(),clearTimeout(a),f(new d({id:n}))},h):void 0,await p}class d extends n.C{constructor({id:t}){super(`Timed out while waiting for call bundle with id "${t}" to be confirmed.`,{name:"WaitForCallsStatusTimeoutError"})}}},44571:(t,e,a)=>{a.d(e,{G:()=>H});var n=a(63127),r=a(83607),s=a(81645);async function i(t,{chain:e}){let{id:a,name:n,nativeCurrency:r,rpcUrls:i,blockExplorers:o}=e;await t.request({method:"wallet_addEthereumChain",params:[{chainId:(0,s.cK)(a),chainName:n,nativeCurrency:r,rpcUrls:i.default.http,blockExplorerUrls:o?Object.values(o).map(({url:t})=>t):void 0}]},{dedupe:!0,retryCount:0})}var o=a(72422),c=a(32544);async function u(t){return t.account?.type==="local"?[t.account.address]:(await t.request({method:"eth_accounts"},{dedupe:!0})).map(t=>(0,c.o)(t))}var d=a(18456),l=a(75687);async function h(t){return await t.request({method:"wallet_getPermissions"},{dedupe:!0})}var m=a(57616),p=a(34472),w=a(96268),f=a(8481),v=a(53422);async function y(t,e){let{account:a=t.account,chainId:n,nonce:s}=e;if(!a)throw new p.T({docsPath:"/docs/eip7702/prepareAuthorization"});let i=(0,m.J)(a),o=(()=>{if(e.executor)return"self"===e.executor?e.executor:(0,m.J)(e.executor)})(),c={address:e.contractAddress??e.address,chainId:n,nonce:s};return void 0===c.chainId&&(c.chainId=t.chain?.id??await (0,f.T)(t,r.T,"getChainId")({})),void 0===c.nonce&&(c.nonce=await (0,f.T)(t,v.y,"getTransactionCount")({address:i.address,blockTag:"pending"}),("self"===o||o?.address&&(0,w.h)(o.address,i.address))&&(c.nonce+=1)),c}var g=a(98861);async function C(t){return(await t.request({method:"eth_requestAccounts"},{dedupe:!0,retryCount:0})).map(t=>(0,c.b)(t))}async function T(t,e){return t.request({method:"wallet_requestPermissions",params:[e]},{retryCount:0})}var b=a(73550),q=a(5579),I=a(81035),_=a(72105);async function A(t,e){let{account:a=t.account}=e;if(!a)throw new p.T({docsPath:"/docs/eip7702/signAuthorization"});let n=(0,m.J)(a);if(!n.signAuthorization)throw new p.Z({docsPath:"/docs/eip7702/signAuthorization",metaMessages:["The `signAuthorization` Action does not support JSON-RPC Accounts."],type:n.type});let r=await y(t,e);return n.signAuthorization(r)}var N=a(84957),E=a(84663),P=a(94770),x=a(20547);async function z(t,e){let{account:a=t.account,chain:n=t.chain,...i}=e;if(!a)throw new p.T({docsPath:"/docs/actions/wallet/signTransaction"});let o=(0,m.J)(a);(0,x.c)({account:o,...e});let c=await (0,f.T)(t,r.T,"getChainId")({});null!==n&&(0,E.v)({currentChainId:c,chain:n});let u=n?.formatters||t.chain?.formatters,d=u?.transactionRequest?.format||P.Bv;return o.signTransaction?o.signTransaction({...i,chainId:c},{serializer:t.chain?.serializers?.transaction}):await t.request({method:"eth_signTransaction",params:[{...d(i),chainId:(0,s.cK)(c),from:o.address}]},{retryCount:0})}var k=a(85450);async function S(t,{id:e}){await t.request({method:"wallet_switchEthereumChain",params:[{chainId:(0,s.cK)(e)}]},{retryCount:0})}var F=a(23272),J=a(21842),K=a(95216);function R(t){return{addChain:e=>i(t,e),deployContract:e=>(0,o.c)(t,e),getAddresses:()=>u(t),getCallsStatus:e=>(0,d.k)(t,e),getCapabilities:e=>(0,l.F)(t,e),getChainId:()=>(0,r.T)(t),getPermissions:()=>h(t),prepareAuthorization:e=>y(t,e),prepareTransactionRequest:e=>(0,g.ft)(t,e),requestAddresses:()=>C(t),requestPermissions:e=>T(t,e),sendCalls:e=>(0,b.yM)(t,e),sendRawTransaction:e=>(0,q.L)(t,e),sendTransaction:e=>(0,I.v)(t,e),showCallsStatus:e=>(0,_.J)(t,e),signAuthorization:e=>A(t,e),signMessage:e=>(0,N.l)(t,e),signTransaction:e=>z(t,e),signTypedData:e=>(0,k.C)(t,e),switchChain:e=>S(t,e),waitForCallsStatus:e=>(0,F.c)(t,e),watchAsset:e=>(0,J.w)(t,e),writeContract:e=>(0,K.E)(t,e)}}var U=a(90203);async function j(t,e={}){return(await (0,U.r)(t,e)).extend(R)}var B=a(24751),M=a(14232),O=a(57742),D=a(8047),L=a(1081),$=a(43387);function H(t={}){let{query:e={},...a}=t,r=(0,$.U)(a),s=(0,n.jE)(),{address:i,connector:o,status:c}=(0,D.F)({config:r}),u=(0,L.i)({config:r}),d=t.connector??o,{queryKey:l,...h}=function(t,e={}){return{gcTime:0,async queryFn({queryKey:a}){let{connector:n}=e,{connectorUid:r,scopeKey:s,...i}=a[1];return j(t,{...i,connector:n})},queryKey:function(t={}){let{connector:e,...a}=t;return["walletClient",{...(0,B.xO)(a),connectorUid:e?.uid}]}(e)}}(r,{...t,chainId:t.chainId??u,connector:t.connector??o}),m=!!(("connected"===c||"reconnecting"===c&&d?.getProvider)&&(e.enabled??!0)),p=(0,M.useRef)(i);return(0,M.useEffect)(()=>{let t=p.current;!i&&t?(s.removeQueries({queryKey:l}),p.current=void 0):i!==t&&(s.invalidateQueries({queryKey:l}),p.current=i)},[i,s]),(0,O.IT)({...e,...h,queryKey:l,enabled:m,staleTime:Number.POSITIVE_INFINITY})}},72105:(t,e,a)=>{a.d(e,{J:()=>n});async function n(t,e){let{id:a}=e;await t.request({method:"wallet_showCallsStatus",params:[a]})}},72422:(t,e,a)=>{a.d(e,{c:()=>s});var n=a(13003),r=a(81035);function s(t,e){let{abi:a,args:s,bytecode:i,...o}=e,c=(0,n.m)({abi:a,args:s,bytecode:i});return(0,r.v)(t,{...o,...o.authorizationList?{to:null}:{},data:c})}},73550:(t,e,a)=>{a.d(e,{BH:()=>m,vB:()=>h,yM:()=>p});var n=a(57616),r=a(76200),s=a(18912),i=a(14237),o=a(58798),c=a(16006),u=a(81645),d=a(46263),l=a(81035);let h="0x5792579257925792579257925792579257925792579257925792579257925792",m=(0,u.cK)(0,{size:32});async function p(t,e){let{account:a=t.account,capabilities:p,chain:w=t.chain,experimental_fallback:f,experimental_fallbackDelay:v=32,forceAtomic:y=!1,id:g,version:C="2.0.0"}=e,T=a?(0,n.J)(a):null,b=e.calls.map(t=>({data:t.abi?(0,i.p)({abi:t.abi,functionName:t.functionName,args:t.args}):t.data,to:t.to,value:t.value?(0,u.cK)(t.value):void 0}));try{let e=await t.request({method:"wallet_sendCalls",params:[{atomicRequired:y,calls:b,capabilities:p,chainId:(0,u.cK)(w.id),from:T?.address,id:g,version:C}]},{retryCount:0});if("string"==typeof e)return{id:e};return e}catch(a){if(f&&("MethodNotFoundRpcError"===a.name||"MethodNotSupportedRpcError"===a.name||a.details.toLowerCase().includes("does not exist / is not available")||a.details.toLowerCase().includes("missing or invalid. request()")||a.details.toLowerCase().includes("did not match any variant of untagged enum"))){if(p&&Object.values(p).some(t=>!t.optional)){let t="non-optional `capabilities` are not supported on fallback to `eth_sendTransaction`.";throw new s.L5(new r.C(t,{details:t}))}if(y&&b.length>1){let t="`forceAtomic` is not supported on fallback to `eth_sendTransaction`.";throw new s.jz(new r.C(t,{details:t}))}let e=[];for(let a of b){let n=(0,l.v)(t,{account:T,chain:w,data:a.data,to:a.to,value:a.value?(0,c.uU)(a.value):void 0});e.push(n),v>0&&await new Promise(t=>setTimeout(t,v))}let a=await Promise.allSettled(e);if(a.every(t=>"rejected"===t.status))throw a[0].reason;let n=a.map(t=>"fulfilled"===t.status?t.value:m);return{id:(0,o.xW)([...n,(0,u.cK)(w.id,{size:32}),h])}}throw(0,d.p)(a,{...e,account:T,chain:e.chain})}}},75687:(t,e,a)=>{a.d(e,{F:()=>s});var n=a(57616),r=a(81645);async function s(t,e={}){let{account:a=t.account,chainId:i}=e,o=a?(0,n.J)(a):void 0,c=i?[o?.address,[(0,r.cK)(i)]]:[o?.address],u=await t.request({method:"wallet_getCapabilities",params:c}),d={};for(let[t,e]of Object.entries(u))for(let[a,n]of(d[Number(t)]={},Object.entries(e)))"addSubAccount"===a&&(a="unstable_addSubAccount"),d[Number(t)][a]=n;return"number"==typeof i?d[i]:d}},85450:(t,e,a)=>{a.d(e,{C:()=>i});var n=a(57616),r=a(34472),s=a(78393);async function i(t,e){let{account:a=t.account,domain:i,message:o,primaryType:c}=e;if(!a)throw new r.T({docsPath:"/docs/actions/wallet/signTypedData"});let u=(0,n.J)(a),d={EIP712Domain:(0,s.H4)({domain:i}),...e.types};if((0,s.$$)({domain:i,message:o,primaryType:c,types:d}),u.signTypedData)return u.signTypedData({domain:i,message:o,primaryType:c,types:d});let l=(0,s.v8)({domain:i,message:o,primaryType:c,types:d});return t.request({method:"eth_signTypedData_v4",params:[u.address,l]},{retryCount:0})}}}]);